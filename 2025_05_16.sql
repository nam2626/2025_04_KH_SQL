-- 제약조건
SELECT * FROM USER_CONSTRAINTS;
-- 기본키
DROP TABLE PERSON;
-- 1. CONSTRAINT 제약조건명 PRIMARY KEY(컬럼) <-- 테이블 생성시
CREATE TABLE PERSON(	
    PID CHAR(4),
    PNAME VARCHAR2(30 BYTE), 
    AGE NUMBER(3,0),
    CONSTRAINT PK_PID PRIMARY KEY(PID)
);
-- 2. ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 PRIMARY KEY(컬럼); <-- 테이블 생성 후
CREATE TABLE PERSON(	
    PID CHAR(4),
    PNAME VARCHAR2(30 BYTE), 
    AGE NUMBER(3,0)
);
ALTER TABLE PERSON ADD CONSTRAINT PK_PID PRIMARY KEY(PID);
--샘플데이터
INSERT INTO PERSON VALUES('0001','홍길동',20);
INSERT INTO PERSON VALUES('0002','김길동',30);
INSERT INTO PERSON VALUES('0003','이길동',40);
INSERT INTO PERSON VALUES('0004','박길동',50);

DROP TABLE PERSON_ORDER;
CREATE TABLE PERSON_ORDER(
	P_ORDER_NO NUMBER(5),
	P_ORDER_MEMO VARCHAR2(300),
	PID CHAR(4)
);
--PERSON_ORDER에 P_ORDER_NO를 기본키로 작성
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_PO_NO_PK
PRIMARY KEY(P_ORDER_NO);
-- 외래키
-- PERSON_ORDER에 PID를 외래키로 설정, PERSON 테이블의 PID와 연결
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_FK_PID
FOREIGN KEY(PID) REFERENCES PERSON(PID);

INSERT INTO PERSON_ORDER VALUES(1, '지시 내용', '0001');
INSERT INTO PERSON_ORDER VALUES(2, '지시 내용', '0002');
INSERT INTO PERSON_ORDER VALUES(3, '지시 내용', '0003');
INSERT INTO PERSON_ORDER VALUES(4, '지시 내용', '0005');

-- PERSON 테이블의 PID값이 0001에 해당하는 레코드 삭제
-- PERSON_ORDER에 0001에 해당하는 데이터가 있어서 삭제 작업을 멈품
DELETE FROM PERSON WHERE PID = '0002'; 
SELECT * FROM PERSON_ORDER;
-- ON DELETE
-- RESTRICT : 기본값, 자식 레코드가 있으면 부모 레코드를 삭제할 수 없음.
-- CASCADE : 부모 레코드 삭제시 관련 자식 레코드도 함께 삭제
-- SET NULL : 부모 레코드 삭제시 관련 자식 레코드의 외래키 값을 NULL로 변경
ALTER TABLE PERSON_ORDER DROP CONSTRAINT PERSON_ORDER_FK_PID;
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_FK_PID
FOREIGN KEY(PID) REFERENCES PERSON(PID) ON DELETE CASCADE;
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_FK_PID
FOREIGN KEY(PID) REFERENCES PERSON(PID) ON DELETE SET NULL;

DROP TABLE PERSON; -- 자식 테이블이 있으면 삭제 안됨
DROP TABLE PERSON CASCADE CONSTRAINTS; -- 자식 테이블의 제약조건을 제거, 자식 테이블까지는 제거 안함.
SELECT * FROM PERSON_ORDER;
SELECT * FROM PERSON;
SELECT * FROM USER_CONSTRAINTS;

--STUDENT 테이블의 학과번호를 외래키로 지정, MAJOR의 테이블의 학과번호로 지정
ALTER TABLE STUDENT ADD CONSTRAINT STD_FK_MNO FOREIGN KEY(MNO) 
REFERENCES MAJOR(MNO);
-- MAJOR 테이블에 기본키 지정이 안되서 에러 발생, 기본키 추가
ALTER TABLE MAJOR ADD CONSTRAINT MAJOR_PK PRIMARY KEY(MNO);
SELECT * FROM MAJOR;
--장학금 테이블 학번 외래키 지정
ALTER TABLE STUDENT_SCHOLARSHIP ADD CONSTRAINT SS_FK_SNO FOREIGN KEY(SNO)
REFERENCES STUDENT(SNO);
-- 1. 장학금 테이블에는 있는데, 학생 테이블에 학번이 없는 데이터 찾아야됨
SELECT SS.SNO, S.*
FROM STUDENT_SCHOLARSHIP SS LEFT OUTER JOIN STUDENT S
ON SS.SNO = S.SNO;
-- 2. 연결이 안된 데이터를 전부 삭제
DELETE FROM STUDENT_SCHOLARSHIP WHERE SNO LIKE '2026%';
DELETE FROM STUDENT_SCHOLARSHIP WHERE SNO IN(SELECT SS.SNO
FROM STUDENT_SCHOLARSHIP SS LEFT OUTER JOIN STUDENT S
ON SS.SNO = S.SNO WHERE S.SNO IS NULL);
-- 학생 테이블에 기본키 지정
ALTER TABLE STUDENT ADD CONSTRAINT STD_PK PRIMARY KEY(SNO);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'STUDENT';
-- 1. NULL 체크
SELECT * FROM STUDENT WHERE SNO IS NULL;
-- 2. 데이터 중복 체크
SELECT SNO, COUNT(*) FROM STUDENT GROUP BY SNO HAVING COUNT(*) >= 2;
DELETE FROM STUDENT WHERE SNO LIKE '20266958';
SELECT FLOOR(DBMS_RANDOM.VALUE * 9000) + 1000 FROM DUAL;
UPDATE STUDENT SET SNO = SUBSTR(SNO,1,4) || (FLOOR(DBMS_RANDOM.VALUE * 9000) + 1000)
WHERE SNO LIKE '2026%'; 
-- CHECK 제약조건(컬럼 조건)
-- 컬럼에 들어올 값의 범위 및 제약 조건을 거는 방법
-- ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 CHECK(조건식);
-- CONSTRAINT 제약조건명 CHECK(조건식) <-- 테이블 생성시 넣을때
-- PERSON 테이블에 나이가 0보다 큰값만 저장되게끔 제약조건을 설정
ALTER TABLE PERSON ADD CONSTRAINT CHK_PAGE CHECK(PAGE > 0);
INSERT INTO PERSON VALUES('0021','김철수',-1);
INSERT INTO PERSON VALUES('0020','김철수',56);
--특정 제약 조건을 비활성화
ALTER TABLE PERSON DISABLE CONSTRAINT CHK_PAGE;
--특정 제약 조건을 활성화 -> 다시 활성화 할때 제약조건 다시 체크
ALTER TABLE PERSON ENABLE CONSTRAINT CHK_PAGE;
DELETE FROM PERSON WHERE PAGE <= 0;
--PERSON 테이블에 데이터 추가시 이름에 공백이 들어가지 않도록 제약조건을 설정
ALTER TABLE PERSON ADD CONSTRAINT CHK_NAME_SPACE CHECK(INSTR(PNAME,' ') = 0);
INSERT INTO PERSON VALUES('0030','김 홍수',33);
--학생 테이블에 평점이 0.0~4.5까지만 저장되게끔 제약조건을 추가
ALTER TABLE STUDENT ADD CONSTRAINT CHK_SCORE CHECK(SCORE BETWEEN 0 AND 4.5);
INSERT INTO STUDENT VALUES('11111111','테스트',4.6,'M','M01');

-- Sub Query(서브 쿼리)
-- 하나의 SQL문에 또 다른 SQL문이 있는 형태
-- 단일 행,멀티 행,멀티 열,인라인 뷰,스칼라,상호연관,exists / not exists

-- 조건식에 들어가는 서브쿼리
-- 평점이 최고점에 해당하는 학생 정보를 조회
-- 1. 학생 테이블에서 최고점에 해당하는 점수를 조회
SELECT MAX(SCORE) FROM STUDENT;
-- 2. 1번 값을 조건식에서 활용
SELECT * FROM STUDENT 
WHERE SCORE = (SELECT MAX(SCORE) FROM STUDENT);
-- 평점이 전체 평균 이하인 학생 정보를 조회
SELECT AVG(SCORE) FROM STUDENT;
SELECT * FROM STUDENT 
WHERE SCORE <= (SELECT AVG(SCORE) FROM STUDENT);
-- 평점이 최저점인 학생 데이터를 삭제
DELETE FROM STUDENT WHERE SCORE = (SELECT MIN(SCORE) FROM STUDENT);
--평점이 최고점인 학생과, 최저점인 학생을 조회
--조회할 컬럼은 학번, 이름, 학과명, 평점, 성별
SELECT MIN(SCORE) FROM STUDENT;
SELECT MAX(SCORE) FROM STUDENT;
SELECT S.SNO, S.SNAME, S.SCORE, S.GENDER, M.MNAME
FROM STUDENT S INNER JOIN MAJOR M ON S.MNO = M.MNO;

SELECT S.SNO, S.SNAME, S.SCORE, S.GENDER, M.MNAME
FROM STUDENT S INNER JOIN MAJOR M ON S.MNO = M.MNO
WHERE 
S.SCORE = (SELECT MIN(SCORE) FROM STUDENT)
OR
S.SCORE = (SELECT MAX(SCORE) FROM STUDENT);

SELECT S.SNO, S.SNAME, S.SCORE, S.GENDER, M.MNAME
FROM STUDENT S INNER JOIN MAJOR M ON S.MNO = M.MNO
WHERE 
S.SCORE IN((SELECT MIN(SCORE) FROM STUDENT),(SELECT MAX(SCORE) FROM STUDENT));

--평균 이하인 학생들의 평점을 0.5점 증가
UPDATE STUDENT SET SCORE = SCORE + 4.5
WHERE SCORE <= (SELECT AVG(SCORE) FROM STUDENT);
--장학금을 받는 학생들만조회
--학번, 이름, 학과명, 평점

--장학금을 받는 못하는 학생들만조회			






