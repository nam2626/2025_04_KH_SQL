-- 제약조건
SELECT * FROM USER_CONSTRAINTS;
-- 기본키
DROP TABLE PERSON;
-- 1. CONSTRAINT 제약조건명 PRIMARY KEY(컬럼) <-- 테이블 생성시
CREATE TABLE PERSON(	
    PID CHAR(4),
    PNAME VARCHAR2(30 BYTE), 
    AGE NUMBER(3,0),
    CONSTRAINT PK_PID PRIMARY KEY(PID)
);
-- 2. ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 PRIMARY KEY(컬럼); <-- 테이블 생성 후
CREATE TABLE PERSON(	
    PID CHAR(4),
    PNAME VARCHAR2(30 BYTE), 
    AGE NUMBER(3,0)
);
ALTER TABLE PERSON ADD CONSTRAINT PK_PID PRIMARY KEY(PID);
--샘플데이터
INSERT INTO PERSON VALUES('0001','홍길동',20);
INSERT INTO PERSON VALUES('0002','김길동',30);
INSERT INTO PERSON VALUES('0003','이길동',40);
INSERT INTO PERSON VALUES('0004','박길동',50);

DROP TABLE PERSON_ORDER;
CREATE TABLE PERSON_ORDER(
	P_ORDER_NO NUMBER(5),
	P_ORDER_MEMO VARCHAR2(300),
	PID CHAR(4)
);
--PERSON_ORDER에 P_ORDER_NO를 기본키로 작성
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_PO_NO_PK
PRIMARY KEY(P_ORDER_NO);
-- 외래키
-- PERSON_ORDER에 PID를 외래키로 설정, PERSON 테이블의 PID와 연결
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_FK_PID
FOREIGN KEY(PID) REFERENCES PERSON(PID);

INSERT INTO PERSON_ORDER VALUES(1, '지시 내용', '0001');
INSERT INTO PERSON_ORDER VALUES(2, '지시 내용', '0002');
INSERT INTO PERSON_ORDER VALUES(3, '지시 내용', '0003');
INSERT INTO PERSON_ORDER VALUES(4, '지시 내용', '0005');

-- PERSON 테이블의 PID값이 0001에 해당하는 레코드 삭제
-- PERSON_ORDER에 0001에 해당하는 데이터가 있어서 삭제 작업을 멈품
DELETE FROM PERSON WHERE PID = '0002'; 
SELECT * FROM PERSON_ORDER;
-- ON DELETE
-- RESTRICT : 기본값, 자식 레코드가 있으면 부모 레코드를 삭제할 수 없음.
-- CASCADE : 부모 레코드 삭제시 관련 자식 레코드도 함께 삭제
-- SET NULL : 부모 레코드 삭제시 관련 자식 레코드의 외래키 값을 NULL로 변경
ALTER TABLE PERSON_ORDER DROP CONSTRAINT PERSON_ORDER_FK_PID;
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_FK_PID
FOREIGN KEY(PID) REFERENCES PERSON(PID) ON DELETE CASCADE;
ALTER TABLE PERSON_ORDER ADD CONSTRAINT PERSON_ORDER_FK_PID
FOREIGN KEY(PID) REFERENCES PERSON(PID) ON DELETE SET NULL;

DROP TABLE PERSON; -- 자식 테이블이 있으면 삭제 안됨
DROP TABLE PERSON CASCADE CONSTRAINTS; -- 자식 테이블의 제약조건을 제거, 자식 테이블까지는 제거 안함.
SELECT * FROM PERSON_ORDER;
SELECT * FROM PERSON;
SELECT * FROM USER_CONSTRAINTS;

--STUDENT 테이블의 학과번호를 외래키로 지정, MAJOR의 테이블의 학과번호로 지정
ALTER TABLE STUDENT ADD CONSTRAINT STD_FK_MNO FOREIGN KEY(MNO) 
REFERENCES MAJOR(MNO);
-- MAJOR 테이블에 기본키 지정이 안되서 에러 발생, 기본키 추가
ALTER TABLE MAJOR ADD CONSTRAINT MAJOR_PK PRIMARY KEY(MNO);
SELECT * FROM MAJOR;
--장학금 테이블 학번 외래키 지정
ALTER TABLE STUDENT_SCHOLARSHIP ADD CONSTRAINT SS_FK_SNO FOREIGN KEY(SNO)
REFERENCES STUDENT(SNO);
-- 1. 장학금 테이블에는 있는데, 학생 테이블에 학번이 없는 데이터 찾아야됨
SELECT SS.SNO, S.*
FROM STUDENT_SCHOLARSHIP SS LEFT OUTER JOIN STUDENT S
ON SS.SNO = S.SNO;
-- 2. 연결이 안된 데이터를 전부 삭제
DELETE FROM STUDENT_SCHOLARSHIP WHERE SNO LIKE '2026%';
DELETE FROM STUDENT_SCHOLARSHIP WHERE SNO IN(SELECT SS.SNO
FROM STUDENT_SCHOLARSHIP SS LEFT OUTER JOIN STUDENT S
ON SS.SNO = S.SNO WHERE S.SNO IS NULL);
-- 학생 테이블에 기본키 지정
ALTER TABLE STUDENT ADD CONSTRAINT STD_PK PRIMARY KEY(SNO);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'STUDENT';
-- 1. NULL 체크
SELECT * FROM STUDENT WHERE SNO IS NULL;
-- 2. 데이터 중복 체크
SELECT SNO, COUNT(*) FROM STUDENT GROUP BY SNO HAVING COUNT(*) >= 2;
DELETE FROM STUDENT WHERE SNO LIKE '20266958';
SELECT FLOOR(DBMS_RANDOM.VALUE * 9000) + 1000 FROM DUAL;
UPDATE STUDENT SET SNO = SUBSTR(SNO,1,4) || (FLOOR(DBMS_RANDOM.VALUE * 9000) + 1000)
WHERE SNO LIKE '2026%'; 
-- 컬럼 조건(CHECK)


-- Sub Query(서브 쿼리)
